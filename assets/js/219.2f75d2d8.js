(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{543:function(t,a,e){"use strict";e.r(a);var s=e(25),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"es2020-es11"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es2020-es11"}},[t._v("#")]),t._v(" ES2020(ES11)")]),t._v(" "),a("p",[t._v("实际上，ECMAScript 的版本命名从 ES2015（ES6）之后，改为按年份命名，因此没有直接被称为 ES11 的版本。但是，如果你指的是 2020 年发布的版本，那应该是 ECMAScript 2020，也常被简称为 ES2020。ES2020 引入了多个新特性，旨在进一步增强语言的表达能力和性能。以下是一些主要的新增特性：")]),t._v(" "),a("h3",{attrs:{id:"_1-nullish-coalescing-operator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-nullish-coalescing-operator"}},[t._v("#")]),t._v(" 1. Nullish Coalescing Operator ("),a("code",[t._v("??")]),t._v(")")]),t._v(" "),a("ul",[a("li",[t._v("这个新操作符 "),a("code",[t._v("??")]),t._v(" 是一个逻辑操作符，用于在左侧操作数为 "),a("code",[t._v("null")]),t._v(" 或 "),a("code",[t._v("undefined")]),t._v(" 时返回右侧操作数，否则返回左侧操作数。它提供了一种更简洁的空值检查方式。")])]),t._v(" "),a("h3",{attrs:{id:"_2-optional-chaining"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-optional-chaining"}},[t._v("#")]),t._v(" 2. Optional Chaining ("),a("code",[t._v("?.")]),t._v(")")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("?.")]),t._v(" 操作符允许你安全地访问深层嵌套的对象属性，即使中间某个属性不存在也不会抛出错误，而是返回 "),a("code",[t._v("undefined")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"_3-promise-allsettled"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise-allsettled"}},[t._v("#")]),t._v(" 3. Promise.allSettled")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Promise.allSettled")]),t._v(" 方法与 "),a("code",[t._v("Promise.all")]),t._v(" 类似，但它会等到所有 Promise 都完成（无论是 resolve 还是 reject）并返回一个包含每个 Promise 状态的对象数组。")])]),t._v(" "),a("h3",{attrs:{id:"_4-globalthis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-globalthis"}},[t._v("#")]),t._v(" 4. GlobalThis")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("globalThis")]),t._v(" 是一个全局对象的引用，无论在浏览器还是 Node.js 环境下，它都能让你访问到全局作用域。这在跨环境编程时非常有用。")])]),t._v(" "),a("h3",{attrs:{id:"_5-bigint-literals-and-math-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-bigint-literals-and-math-functions"}},[t._v("#")]),t._v(" 5. BigInt Literals and Math Functions")]),t._v(" "),a("ul",[a("li",[t._v("ES2020 扩展了对 "),a("code",[t._v("BigInt")]),t._v(" 的支持，现在可以直接在数字字面量中使用 "),a("code",[t._v("n")]),t._v(" 后缀来创建 "),a("code",[t._v("BigInt")]),t._v("，并且增加了几个与 "),a("code",[t._v("BigInt")]),t._v(" 相关的数学函数。")])]),t._v(" "),a("h3",{attrs:{id:"_6-dynamic-import-assertions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-dynamic-import-assertions"}},[t._v("#")]),t._v(" 6. Dynamic Import Assertions")]),t._v(" "),a("ul",[a("li",[t._v("动态导入 ("),a("code",[t._v("import()")]),t._v(') 现在可以包含断言（assertions），允许你指定导入模块的类型（如 "type": "json"）。')])]),t._v(" "),a("h3",{attrs:{id:"_7-private-class-fields-and-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-private-class-fields-and-methods"}},[t._v("#")]),t._v(" 7. Private Class Fields and Methods")]),t._v(" "),a("ul",[a("li",[t._v("私有类字段和方法现在可以用 "),a("code",[t._v("#")]),t._v(" 前缀定义，这使得类成员的可见性更加明确。")])]),t._v(" "),a("h3",{attrs:{id:"_8-regexp-unicode-property-escapes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-regexp-unicode-property-escapes"}},[t._v("#")]),t._v(" 8. RegExp Unicode Property Escapes")]),t._v(" "),a("ul",[a("li",[t._v("正则表达式中的 Unicode 属性转义现在支持更多字符集，比如 "),a("code",[t._v("\\p{L}")]),t._v(" 可以匹配任何类型的字母。")])]),t._v(" "),a("h3",{attrs:{id:"_9-array-prototype-at"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-array-prototype-at"}},[t._v("#")]),t._v(" 9. Array.prototype.at()")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("at()")]),t._v(" 方法提供了一种更安全地访问数组元素的方式，它支持负数索引，可以更容易地访问数组末尾的元素。")])]),t._v(" "),a("p",[t._v("这些新特性进一步丰富了 JavaScript 的功能，提高了代码的可读性和维护性。随着现代浏览器和 JavaScript 运行时环境对这些特性的支持，开发者可以开始在项目中采用这些新功能，以编写更高效、更安全的代码。")])])}),[],!1,null,null,null);a.default=r.exports}}]);