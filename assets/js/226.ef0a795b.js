(window.webpackJsonp=window.webpackJsonp||[]).push([[226],{552:function(a,t,r){"use strict";r.r(t);var s=r(25),e=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"es8-es2017"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es8-es2017"}},[a._v("#")]),a._v(" ES8(ES2017)")]),a._v(" "),t("p",[a._v("ECMAScript 2017，通常被称为 ES8，是 JavaScript 语言标准的又一更新，发布于 2017 年。ES8 在 ES7 的基础上继续引入了一些新的特性和改进，虽然不像 ES6 那样带来革命性的变化，但这些新特性依然为 JavaScript 开发提供了更多的便利和灵活性。以下是 ES8 中的一些主要新增特性：")]),a._v(" "),t("h3",{attrs:{id:"_1-async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-async-await"}},[a._v("#")]),a._v(" 1. async/await")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("async/await")]),a._v(" 是基于 Promise 的一种新的异步编程语法。"),t("code",[a._v("async")]),a._v(" 关键字用于定义一个异步函数，而 "),t("code",[a._v("await")]),a._v(" 关键字用于等待一个 Promise 的结果。这使得异步代码的编写更加接近于同步代码的风格，提高了代码的可读性和可维护性。")])]),a._v(" "),t("h3",{attrs:{id:"_2-object-getownpropertydescriptors"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-object-getownpropertydescriptors"}},[a._v("#")]),a._v(" 2. Object.getOwnPropertyDescriptors()")]),a._v(" "),t("ul",[t("li",[a._v("这个新方法返回一个对象，其中包含了目标对象所有自身属性的描述符。这在复制或迁移对象属性时非常有用。")])]),a._v(" "),t("h3",{attrs:{id:"_3-string-padding-methods-padstart-and-padend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-string-padding-methods-padstart-and-padend"}},[a._v("#")]),a._v(" 3. String padding methods: padStart() and padEnd()")]),a._v(" "),t("ul",[t("li",[a._v("ES7 实际上已经引入了这些方法，但在 ES8 中它们得到了进一步的标准化和确认。这些方法允许你在字符串的开头或结尾添加填充字符，直到达到指定的长度。")])]),a._v(" "),t("h3",{attrs:{id:"_4-trailing-commas-in-function-arguments-and-calls"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-trailing-commas-in-function-arguments-and-calls"}},[a._v("#")]),a._v(" 4. Trailing commas in function arguments and calls")]),a._v(" "),t("ul",[t("li",[a._v("允许在函数参数列表和调用中使用尾随逗号，这在编写多行参数列表时提高了代码的可读性，并且在添加或移除参数时减少了重构的工作量。")])]),a._v(" "),t("h3",{attrs:{id:"_5-sharedarraybuffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-sharedarraybuffer"}},[a._v("#")]),a._v(" 5. SharedArrayBuffer")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("SharedArrayBuffer")]),a._v(" 是一个新的全局对象，它表示一个可以被多个 JavaScript 线程共享的固定大小的原始二进制数据缓冲区。结合 "),t("code",[a._v("Atomics")]),a._v(" 对象，它支持原子操作，使得在 Web Workers 中进行高效共享内存操作成为可能。")])]),a._v(" "),t("h3",{attrs:{id:"_6-copywithin-fill-and-findindex-array-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-copywithin-fill-and-findindex-array-methods"}},[a._v("#")]),a._v(" 6. CopyWithin, Fill, and FindIndex array methods")]),a._v(" "),t("ul",[t("li",[a._v("这些方法进一步扩展了数组的功能。"),t("code",[a._v("Array.prototype.copyWithin")]),a._v(" 允许你复制数组的一部分到数组的另一部分，"),t("code",[a._v("Array.prototype.fill")]),a._v(" 用于填充数组的一部分或全部元素为指定的静态值，"),t("code",[a._v("Array.prototype.findIndex")]),a._v(" 则用于找到第一个满足提供的测试函数的数组元素的索引。")])]),a._v(" "),t("h3",{attrs:{id:"_7-async-iterators-and-generators"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-async-iterators-and-generators"}},[a._v("#")]),a._v(" 7. Async Iterators and Generators")]),a._v(" "),t("ul",[t("li",[a._v("虽然完整的异步迭代器和生成器的支持在 ES8 中没有完全实现，但 ES8 引入了必要的基础设施，包括 "),t("code",[a._v("@@asyncIterator")]),a._v(" 符号，为未来的异步迭代打下了基础。")])]),a._v(" "),t("p",[a._v("ES8 的这些特性不仅增强了 JavaScript 的语言功能，也反映了社区对更高效、更安全的异步编程和多线程支持的需求。随着这些特性的逐步标准化和浏览器的支持，JavaScript 的应用场景和能力得到了进一步的扩展。")])])}),[],!1,null,null,null);t.default=e.exports}}]);