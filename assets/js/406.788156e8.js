(window.webpackJsonp=window.webpackJsonp||[]).push([[406],{732:function(s,t,n){"use strict";n.r(t);var a=n(25),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"双向数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定"}},[s._v("#")]),s._v(" 双向数据绑定")]),s._v(" "),t("h3",{attrs:{id:"_1-vue-的双向数据绑定原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-的双向数据绑定原理"}},[s._v("#")]),s._v(" （1）Vue 的双向数据绑定原理")]),s._v(" "),t("div",{staticClass:"language-md line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[s._v("Vue.js 的双向数据绑定机制是其核心特性之一，它让开发者能够轻松地在视图（View）和模型（Model）之间同步数据。在 Vue.js 中，双向数据绑定主要通过以下几个关键概念和技术实现：\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("1.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("响应式系统")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Vue.js 使用一种基于数据观察的响应式系统来追踪数据的变化。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当数据发生变化时，与之相关联的视图会自动更新。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Vue 会利用 JavaScript 的 Object.defineProperty() 方法来把数据对象的属性转换成 getter/setter。\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("2.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("数据劫持")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Vue 会在初始化时遍历 data 对象中的所有属性，并使用 Object.defineProperty() 来将其转换为 getter/setter 形式的属性。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" getter 用于获取数据值，setter 用于设置数据值并触发依赖更新。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当一个属性被访问时，Vue 会记录这个依赖关系；当该属性被修改时，Vue 会通知所有依赖它的组件重新渲染。\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("3.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("依赖收集与更新")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当渲染函数执行时，它会遍历 data 对象中的属性，并将这些属性添加到依赖列表中。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 每个观察者都有一个依赖列表，当数据变化时，会触发对应的观察者去更新它们所关联的 DOM 元素。\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("4.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("Watcher 观察者")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Watcher 是 Vue 中的一个核心类，它负责更新视图。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当数据变化时，setter 函数会被调用，并且通知所有依赖该数据的 Watcher 进行更新。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Watcher 会跟踪依赖并在数据变化时执行更新视图的方法。\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("5.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("指令（Directives）")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Vue 提供了多种内置指令，如 v-model 和 v-bind。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" v-model 是一个特殊的指令，它实现了表单控件的双向数据绑定。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当用户在输入框中输入数据时，v-model 会监听 input 事件，并更新 data 中的数据。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 同样地，当 data 中的数据发生变化时，v-model 会更新表单控件的值。\n\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("6.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token bold"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")]),t("span",{pre:!0,attrs:{class:"token content"}},[s._v("脏检查（Dirty Checking）")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("**")])]),s._v("：\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" Vue.js 不使用脏检查（AngularJS 中的一种机制），而是采用了更高效的依赖追踪和异步队列机制。\n   "),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[s._v("-")]),s._v(" 当数据改变时，Vue 会异步执行渲染函数以更新视图，而不是立即更新。\n\n总结来说，Vue.js 的双向数据绑定是通过数据劫持结合发布订阅模式来实现的。当数据发生变化时，Vue 会自动更新 DOM，而不需要显式地调用任何方法。\n\n在面试中，你可以通过解释上述原理来展示你对 Vue.js 内部机制的理解。此外，还可以简单说明 Vue.js 如何优化性能，比如通过异步更新队列避免不必要的重绘和回流。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br"),t("span",{staticClass:"line-number"},[s._v("36")]),t("br"),t("span",{staticClass:"line-number"},[s._v("37")]),t("br"),t("span",{staticClass:"line-number"},[s._v("38")]),t("br"),t("span",{staticClass:"line-number"},[s._v("39")]),t("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);