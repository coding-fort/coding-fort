(window.webpackJsonp=window.webpackJsonp||[]).push([[343],{668:function(t,a,r){"use strict";r.r(a);var e=r(25),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"创建型设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建型设计模式"}},[t._v("#")]),t._v(" 创建型设计模式")]),t._v(" "),a("p",[t._v("创建型设计模式关注于对象的创建机制，帮助将对象的创建与使用分离，以达到解耦的目的。")]),t._v(" "),a("h2",{attrs:{id:"工厂模式-factory-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式-factory-pattern"}},[t._v("#")]),t._v(" 工厂模式（Factory Pattern）")]),t._v(" "),a("p",[t._v("提供了一个创建对象的接口，但允许子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类。")]),t._v(" "),a("h2",{attrs:{id:"抽象工厂模式-abstract-factory-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式-abstract-factory-pattern"}},[t._v("#")]),t._v(" 抽象工厂模式（Abstract Factory Pattern）")]),t._v(" "),a("p",[t._v("提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。")]),t._v(" "),a("h2",{attrs:{id:"单例模式-singleton-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式-singleton-pattern"}},[t._v("#")]),t._v(" 单例模式（Singleton Pattern）")]),t._v(" "),a("p",[t._v("确保一个类只有一个实例，并提供一个全局访问点。")]),t._v(" "),a("h2",{attrs:{id:"建造者模式-builder-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式-builder-pattern"}},[t._v("#")]),t._v(" 建造者模式（Builder Pattern）")]),t._v(" "),a("p",[t._v("将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。")]),t._v(" "),a("h2",{attrs:{id:"原型模式-prototype-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型模式-prototype-pattern"}},[t._v("#")]),t._v(" 原型模式（Prototype Pattern）")]),t._v(" "),a("p",[t._v("用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。")])])}),[],!1,null,null,null);a.default=s.exports}}]);