(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{546:function(a,r,e){"use strict";e.r(r);var t=e(25),s=Object(t.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"es2021-es12"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es2021-es12"}},[a._v("#")]),a._v(" ES2021(ES12)")]),a._v(" "),r("p",[a._v("ECMAScript 2021，也称为 ES2021 或 ES12，是 JavaScript 语言标准的 2021 年版本。虽然相较于之前的版本，ES2021 的新增特性相对较少，但仍然包含了一些实用的改进和功能增强。以下是 ES2021 中的一些主要新增特性：")]),a._v(" "),r("h3",{attrs:{id:"_1-logical-assignment-operators-and"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-logical-assignment-operators-and"}},[a._v("#")]),a._v(" 1. Logical Assignment Operators ("),r("code",[a._v("&&=")]),a._v(" and "),r("code",[a._v("||=")]),a._v(")")]),a._v(" "),r("ul",[r("li",[a._v("逻辑赋值操作符允许你结合逻辑 AND ("),r("code",[a._v("&&")]),a._v(") 或 OR ("),r("code",[a._v("||")]),a._v(") 和赋值操作。例如，"),r("code",[a._v("x ||= y")]),a._v(" 相当于 "),r("code",[a._v("x = x || y")]),a._v("，但更简洁。")])]),a._v(" "),r("h3",{attrs:{id:"_2-string-prototype-matchall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-string-prototype-matchall"}},[a._v("#")]),a._v(" 2. String.prototype.matchAll")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("matchAll")]),a._v(" 方法类似于 "),r("code",[a._v("match")]),a._v("，但返回一个迭代器，该迭代器会产生所有匹配正则表达式的子串，包括非全局模式下的所有匹配。")])]),a._v(" "),r("h3",{attrs:{id:"_3-promise-any-and-aggregateerror"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise-any-and-aggregateerror"}},[a._v("#")]),a._v(" 3. Promise.any and AggregateError")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("Promise.any")]),a._v(" 接受一个 Promise 数组，当其中任何一个 Promise 解析时，它会立即解析。如果所有 Promise 都被拒绝，则会拒绝 "),r("code",[a._v("Promise.any")]),a._v("，并使用一个新的 "),r("code",[a._v("AggregateError")]),a._v(" 对象，其中包含所有拒绝的原因。")])]),a._v(" "),r("h3",{attrs:{id:"_4-weakrefs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-weakrefs"}},[a._v("#")]),a._v(" 4. WeakRefs")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("WeakRef")]),a._v(" 是一个构造函数，用于创建弱引用，这使得垃圾回收器可以自由地回收被弱引用的对象，即使还有对该对象的引用存在。这可以防止内存泄漏，并且在实现某些类型的数据结构和模式时非常有用。")])]),a._v(" "),r("h3",{attrs:{id:"_5-realms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-realms"}},[a._v("#")]),a._v(" 5. Realms")]),a._v(" "),r("ul",[r("li",[a._v("Realms 提供了一种机制来隔离和管理独立的执行环境，这对于沙盒环境和插件系统等场景非常有用。")])]),a._v(" "),r("h3",{attrs:{id:"_6-numeric-separators"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-numeric-separators"}},[a._v("#")]),a._v(" 6. Numeric Separators")]),a._v(" "),r("ul",[r("li",[a._v("虽然数字分隔符在 ES2018 中已经被提出，但在 ES2021 中，这种语法扩展到了八进制和十六进制数字字面量，使得大数的表示更加清晰。")])]),a._v(" "),r("h3",{attrs:{id:"_7-string-prototype-replaceall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-string-prototype-replaceall"}},[a._v("#")]),a._v(" 7. String.prototype.replaceAll")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("replaceAll")]),a._v(" 方法类似于 "),r("code",[a._v("replace")]),a._v("，但会替换字符串中所有匹配的子串，而不仅仅是第一个匹配。")])]),a._v(" "),r("p",[a._v("这些新特性进一步增强了 JavaScript 的表达能力和功能性，使得开发人员能够以更简洁、更安全的方式编写代码。随着浏览器和 JavaScript 运行时环境对这些特性的支持，开发者可以开始在实际项目中利用这些新功能。")])])}),[],!1,null,null,null);r.default=s.exports}}]);