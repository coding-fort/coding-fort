(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{548:function(r,t,a){"use strict";a.r(t);var e=a(25),o=Object(e.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"es2023-es14"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es2023-es14"}},[r._v("#")]),r._v(" ES2023(ES14)")]),r._v(" "),t("p",[r._v("ECMAScript 2023，也称为 ES2023 或 ES14，是 JavaScript 的最新标准之一，继续遵循了每年更新一次的传统。虽然 ES2023 的更新相对于前几年的版本来说较为低调，但它仍包含了一些值得注意的新特性和改进，旨在提升开发者的编码体验和语言的实用性。以下是 ES2023 中的一些主要新增特性：")]),r._v(" "),t("h3",{attrs:{id:"_1-error-causation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-error-causation"}},[r._v("#")]),r._v(" 1. Error Causation")]),r._v(" "),t("ul",[t("li",[r._v("此特性已在 ES2022 中提及，但在 ES2023 中进一步标准化和细化。"),t("code",[r._v("Error")]),r._v(" 对象的 "),t("code",[r._v("cause")]),r._v(" 属性允许开发者链接到触发当前错误的原始错误，提供更丰富的错误上下文，便于调试。")])]),r._v(" "),t("h3",{attrs:{id:"_2-record-and-tuple-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-record-and-tuple-types"}},[r._v("#")]),r._v(" 2. Record and Tuple Types")]),r._v(" "),t("ul",[t("li",[r._v("引入了 "),t("code",[r._v("record")]),r._v(" 和 "),t("code",[r._v("tuple")]),r._v(" 类型，虽然目前仅限于 TypeScript 等类型系统的静态类型定义，但展示了未来 JavaScript 类型系统的发展方向。这些类型提供了一种更精细的方式来描述和验证数据结构。")])]),r._v(" "),t("h3",{attrs:{id:"_3-array-prototype-toreversed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-array-prototype-toreversed"}},[r._v("#")]),r._v(" 3. Array.prototype.toReversed()")]),r._v(" "),t("ul",[t("li",[r._v("新增了一个数组实例方法 "),t("code",[r._v("toReversed()")]),r._v("，它返回一个反转顺序的新数组，而不修改原数组。这为数组操作提供了一种更直观的非破坏性方法。")])]),r._v(" "),t("h3",{attrs:{id:"_4-array-prototype-tosorted"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-array-prototype-tosorted"}},[r._v("#")]),r._v(" 4. Array.prototype.toSorted()")]),r._v(" "),t("ul",[t("li",[r._v("同样是一个非破坏性的排序方法，"),t("code",[r._v("toSorted()")]),r._v(" 允许你根据提供的比较函数对数组元素进行排序，并返回一个新的排序后的数组。")])]),r._v(" "),t("h3",{attrs:{id:"_5-array-prototype-with"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-array-prototype-with"}},[r._v("#")]),r._v(" 5. Array.prototype.with()")]),r._v(" "),t("ul",[t("li",[t("code",[r._v("with()")]),r._v(" 方法允许你创建一个数组的浅复制，并替换其中的某个元素，而不改变原数组。这对于函数式编程风格和不可变数据结构的支持非常有用。")])]),r._v(" "),t("h3",{attrs:{id:"_6-string-prototype-replaceall"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-string-prototype-replaceall"}},[r._v("#")]),r._v(" 6. String.prototype.replaceAll()")]),r._v(" "),t("ul",[t("li",[r._v("虽然 "),t("code",[r._v("replaceAll()")]),r._v(" 方法已经在 ES2021 中引入，但在 ES2023 中对其进行了标准化和细化，以确保跨平台的一致性。")])]),r._v(" "),t("h3",{attrs:{id:"_7-temporal-improvements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-temporal-improvements"}},[r._v("#")]),r._v(" 7. Temporal Improvements")]),r._v(" "),t("ul",[t("li",[r._v("Temporal 模块在 ES2022 中首次亮相，ES2023 对其进行了改进和扩展，提供了更强大的日期和时间处理功能，包括时区处理、日期计算等。")])]),r._v(" "),t("h3",{attrs:{id:"_8-numeric-separators-for-binary-and-octal-literals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-numeric-separators-for-binary-and-octal-literals"}},[r._v("#")]),r._v(" 8. Numeric Separators for Binary and Octal Literals")]),r._v(" "),t("ul",[t("li",[r._v("数字分隔符 "),t("code",[r._v("_")]),r._v(" 的使用在 ES2022 中已经扩展到了二进制和八进制数字字面量，在 ES2023 中进一步巩固了这一特性，使其更加稳定和可靠。")])]),r._v(" "),t("p",[r._v("这些新特性展示了 JavaScript 语言的持续发展，特别是对于数据处理、错误管理和类型安全的关注。随着这些特性的标准化，开发者可以期待在未来的 JavaScript 环境中更加高效和安全地编写代码。然而，需要注意的是，新特性的实际可用性取决于浏览器和 JavaScript 引擎的支持情况。")])])}),[],!1,null,null,null);t.default=o.exports}}]);