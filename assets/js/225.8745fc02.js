(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{551:function(t,e,a){"use strict";a.r(e);var r=a(25),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"es7-es2016"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es7-es2016"}},[t._v("#")]),t._v(" ES7(ES2016)")]),t._v(" "),e("p",[t._v("ECMAScript 2016，通常被称为 ES7，是 JavaScript 标准的一个年度更新版本，于 2016 年正式发布。相对于 ES6（ECMAScript 2015），ES7 引入的新增特性相对较少，但依然有一些重要的改进，主要包括：")]),t._v(" "),e("h3",{attrs:{id:"_1-指数运算符-exponentiation-operator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-指数运算符-exponentiation-operator"}},[t._v("#")]),t._v(" 1. 指数运算符（Exponentiation Operator）")]),t._v(" "),e("ul",[e("li",[t._v("引入了指数运算符 "),e("code",[t._v("**")]),t._v("，用于快速计算幂次方。例如，"),e("code",[t._v("2 ** 3")]),t._v(" 等价于 "),e("code",[t._v("Math.pow(2, 3)")]),t._v("，结果为 "),e("code",[t._v("8")]),t._v("。同时，还引入了 "),e("code",[t._v("Math.expm1")]),t._v(" 和 "),e("code",[t._v("Math.log1p")]),t._v(" 等数学函数。")])]),t._v(" "),e("h3",{attrs:{id:"_2-array-prototype-includes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-array-prototype-includes"}},[t._v("#")]),t._v(" 2. Array.prototype.includes()")]),t._v(" "),e("ul",[e("li",[t._v("添加了 "),e("code",[t._v("includes()")]),t._v(" 方法到数组原型上，用于判断一个数组是否包含特定的元素，类似于字符串的 "),e("code",[t._v("includes")]),t._v(" 方法。例如，"),e("code",[t._v("[1, 2, 3].includes(2)")]),t._v(" 返回 "),e("code",[t._v("true")]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"_3-array-prototype-entries-keys-和-values"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-array-prototype-entries-keys-和-values"}},[t._v("#")]),t._v(" 3. Array.prototype.entries()，keys() 和 values()")]),t._v(" "),e("ul",[e("li",[t._v("引入了这三个数组实例方法，使得数组可以像 Map 或 Set 那样使用 "),e("code",[t._v("for...of")]),t._v(" 循环进行迭代。"),e("code",[t._v("entries()")]),t._v(" 返回数组的键值对迭代器，"),e("code",[t._v("keys()")]),t._v(" 返回索引迭代器，"),e("code",[t._v("values()")]),t._v(" 返回元素迭代器。")])]),t._v(" "),e("h3",{attrs:{id:"_4-string-prototype-padstart-和-padend"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-string-prototype-padstart-和-padend"}},[t._v("#")]),t._v(" 4. String.prototype.padStart() 和 padEnd()")]),t._v(" "),e("ul",[e("li",[t._v("这两个方法用于在字符串的开始或结束填充字符，直到达到指定的长度。例如，"),e("code",[t._v("'1'.padStart(3, '0')")]),t._v(" 返回 "),e("code",[t._v("'001'")]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"_5-object-values-和-object-entries"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-object-values-和-object-entries"}},[t._v("#")]),t._v(" 5. Object.values() 和 Object.entries()")]),t._v(" "),e("ul",[e("li",[t._v("这两个方法用于获取对象的所有值和键值对。"),e("code",[t._v("Object.values(obj)")]),t._v(" 返回一个数组，包含了对象自身的所有可枚举属性的值；"),e("code",[t._v("Object.entries(obj)")]),t._v(" 返回一个数组，包含了对象自身所有的 [key, value] 键值对。")])]),t._v(" "),e("h3",{attrs:{id:"_6-promise-prototype-finally"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-promise-prototype-finally"}},[t._v("#")]),t._v(" 6. Promise.prototype.finally()")]),t._v(" "),e("ul",[e("li",[t._v("虽然这个提议最初是在 ES7 阶段提出的，但实际上它没有被正式采纳到 ES7 标准中，而是后来在 ES2018 中被标准化。"),e("code",[t._v("finally")]),t._v(" 方法允许在 promise 完成（无论成功还是失败）后执行一段代码，这在清理资源等场景下很有用。")])]),t._v(" "),e("p",[t._v("ES7 的这些新增特性进一步增强了 JavaScript 的实用性，尤其是在数学运算、数组和字符串处理方面。然而，相比于 ES6 的大规模革新，ES7 的变化相对较小，更多的是对现有 API 的补充和完善。随着 ES 标准的每年更新，JavaScript 语言持续进化，为开发者提供了更多强大而便捷的工具。")])])}),[],!1,null,null,null);e.default=v.exports}}]);