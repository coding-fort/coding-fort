(window.webpackJsonp=window.webpackJsonp||[]).push([[339],{666:function(v,_,o){"use strict";o.r(_);var e=o(25),s=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"模块化规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化规范"}},[v._v("#")]),v._v(" 模块化规范")]),v._v(" "),_("p",[v._v("JavaScript 的模块化规范经历了多年的发展，旨在帮助开发者更好地组织代码，避免全局命名空间的污染，以及实现代码的复用和维护。以下是一些主要的模块化规范及其特点：")]),v._v(" "),_("p",[_("img",{attrs:{src:"/images/module-01.jpg#pic_center",alt:"模块化规范发展"}})]),v._v(" "),_("p",{staticStyle:{"text-align":"center"}},[v._v("模块化规范发展")]),v._v(" "),_("h3",{attrs:{id:"commonjs-cjs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-cjs"}},[v._v("#")]),v._v(" CommonJS (CJS)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("出现时间")]),v._v("：2009 年左右")]),v._v(" "),_("li",[_("strong",[v._v("适用环境")]),v._v("：主要用于"),_("sucb",[v._v("服务器端")]),v._v("，如 Node.js 环境")],1),v._v(" "),_("li",[_("strong",[v._v("加载方式")]),v._v("：同步加载")]),v._v(" "),_("li",[_("strong",[v._v("模块定义")]),v._v("：使用"),_("code",[v._v("module.exports")]),v._v("或"),_("code",[v._v("exports")]),v._v("来导出模块的接口，使用"),_("code",[v._v("require")]),v._v("来加载模块。")]),v._v(" "),_("li",[_("strong",[v._v("文件扩展名")]),v._v("：通常不需要在"),_("code",[v._v("require")]),v._v("语句中指定文件扩展名，Node.js 会尝试加载"),_("code",[v._v(".js")]),v._v("、"),_("code",[v._v(".json")]),v._v("和"),_("code",[v._v(".node")]),v._v("等文件。")])]),v._v(" "),_("h3",{attrs:{id:"amd-asynchronous-module-definition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#amd-asynchronous-module-definition"}},[v._v("#")]),v._v(" AMD (Asynchronous Module Definition)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("出现时间")]),v._v("：2011 年左右")]),v._v(" "),_("li",[_("strong",[v._v("设计哲学")]),v._v("：AMD 规范是为了解决异步加载模块的需求，它允许模块在需要的时候"),_("err",[v._v("动态加载")]),v._v("，而不是一次性加载所有模块。")],1),v._v(" "),_("li",[_("strong",[v._v("适用环境")]),v._v("：主要用于"),_("sucb",[v._v("浏览器端")]),v._v("，解决异步加载问题")],1),v._v(" "),_("li",[_("strong",[v._v("加载方式")]),v._v("：异步加载")]),v._v(" "),_("li",[_("strong",[v._v("模块定义")]),v._v("：使用"),_("code",[v._v("define")]),v._v("函数定义模块，使用"),_("code",[v._v("require")]),v._v("函数加载模块。AMD 规范推荐使用异步加载，以提高加载速度和用户体验。")]),v._v(" "),_("li",[_("strong",[v._v("文件扩展名")]),v._v("：需要在"),_("code",[v._v("require")]),v._v("语句中指定文件扩展名。")])]),v._v(" "),_("h3",{attrs:{id:"umd-universal-module-definition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#umd-universal-module-definition"}},[v._v("#")]),v._v(" UMD (Universal Module Definition)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("出现时间")]),v._v("：介于 CommonJS 和 AMD 之间")]),v._v(" "),_("li",[_("strong",[v._v("设计哲学")]),v._v("：UMD 规范是为了兼容多种模块化环境而设计的，它能适应 CommonJS、AMD 和无模块化（即全局变量）的环境。")]),v._v(" "),_("li",[_("strong",[v._v("适用环境")]),v._v("：可以在 CommonJS、AMD 和全局变量环境下运行")]),v._v(" "),_("li",[_("strong",[v._v("加载方式")]),v._v("：既可以同步加载也可以异步加载，取决于加载环境")]),v._v(" "),_("li",[_("strong",[v._v("模块定义")]),v._v("：UMD 模块定义了一种混合模式，可以适应不同的模块加载环境。它通常会检测"),_("code",[v._v("define")]),v._v("是否存在（AMD），或者"),_("code",[v._v("module.exports")]),v._v("是否存在（CommonJS），并在最后提供一个全局变量的回退方案。")])]),v._v(" "),_("h3",{attrs:{id:"cmd-common-module-definition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cmd-common-module-definition"}},[v._v("#")]),v._v(" CMD (Common Module Definition)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("出现时间")]),v._v("：2011 年左右发布 SeaJS 后")]),v._v(" "),_("li",[_("strong",[v._v("设计哲学")]),v._v("：CMD 规范同样支持异步加载，但它更注重"),_("err",[v._v("模块的执行顺序和依赖管理")]),v._v("，确保依赖模块在当前模块执行前加载完成。")],1),v._v(" "),_("li",[_("strong",[v._v("适用环境")]),v._v("：主要用于"),_("sucb",[v._v("浏览器端")]),v._v("，适合于大型 Web 应用，尤其是那些需要动态加载和按需加载资源的场景，如单页应用（SPA）")],1),v._v(" "),_("li",[_("strong",[v._v("加载方式")]),v._v("：CMD 也是异步加载，但更加强调模块间的依赖关系和执行顺序。")]),v._v(" "),_("li",[_("strong",[v._v("模块缓存")]),v._v("：加载过的模块会被缓存，这意味着如果同一个模块被多次加载，第二次及以后的加载将直接从缓存中读取，避免了重复加载。")]),v._v(" "),_("li",[_("strong",[v._v("模块作用域")]),v._v("：每个 CMD 模块都有自己的作用域，这避免了全局变量的污染，使得模块之间更加独立，易于维护和扩展。")])]),v._v(" "),_("h3",{attrs:{id:"es-modules-esm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es-modules-esm"}},[v._v("#")]),v._v(" "),_("errb",[v._v("ES Modules (ESM)")])],1),v._v(" "),_("ul",[_("li",[_("strong",[v._v("出现时间")]),v._v("：随 ES2015（ES6）标准引入")]),v._v(" "),_("li",[_("strong",[v._v("适用环境")]),v._v("：现代"),_("sucb",[v._v("浏览器和 Node.js")]),v._v("（从 v12 开始默认支持）")],1),v._v(" "),_("li",[_("strong",[v._v("加载方式")]),v._v("：异步加载，使用"),_("code",[v._v("import")]),v._v("和"),_("code",[v._v("export")]),v._v("语法")]),v._v(" "),_("li",[_("strong",[v._v("模块定义")]),v._v("：使用"),_("code",[v._v("export")]),v._v("语句导出模块接口，使用"),_("code",[v._v("import")]),v._v("语句导入模块。ES 模块在设计上考虑了静态分析，这使得工具和编辑器可以更好地理解代码结构。")]),v._v(" "),_("li",[_("strong",[v._v("文件扩展名")]),v._v("：通常需要指定"),_("code",[v._v(".mjs")]),v._v("扩展名，但在现代浏览器和最新的 Node.js 版本中，"),_("code",[v._v(".js")]),v._v("文件也可以被识别为 ES 模块，只要在"),_("code",[v._v("<script>")]),v._v("标签中设置了"),_("code",[v._v('type="module"')]),v._v("属性或在 Node.js 中设置相应选项。")])]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("随着 ES Modules 在现代 JavaScript 环境中的广泛支持，它已经成为新的标准，被大多数前端框架和库所采用。然而，由于历史遗留和兼容性问题，CommonJS 和 AMD 在一些项目中仍然被使用。对于新的项目，推荐使用 ES Modules，因为它提供了更强大和灵活的模块化解决方案。")])])}),[],!1,null,null,null);_.default=s.exports}}]);